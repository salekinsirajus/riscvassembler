%{
    //for flex
    #include <iostream>
    #include <stdio.h>
    #include "linux/elf.h"

    //generated by bison
    #include "riscvass.tab.h"

    using namespace std;
    extern int yylex();
    extern int yyparse();

    int linenum = 0;
    int charnum = 0;
%}

%option noyywrap

/* named regexes */

%%
[\t ]            {; }
"#".*            {; /* ignore everything this line */ }
[\n]             { ++linenum; charnum=0; }
[\\n]            { ++linenum; charnum=0; }
"("              { return PAREN_OPEN; }
")"              { return PAREN_CLOSE; }
":"              { return COLON; }

"j"              { return JUMP; }

"add"            { return ADD; }
"addi"           { return ADDI; }
"and"            { return AND; }
"andi"           { return ANDI; }
"sub"            { return SUB; }
"subi"           { return SUBI; }
"li"             { return LI; }
"beq"            { return BEQ; }
"bne"            { return BNE; }
"bge"            { return BGE; }
"bgeu"           { return BGEU; }
"blt"            { return BLT; }
"bltu"           { return BLTU; }
"la"             { return LA; }
"lb"             { return LB; }
"lbu"            { return LBU; }
"lh"             { return LH; }
"lhu"            { return LHU; }
"lw"             { return LW; }
"mv"             { return MOV; }
"or"             { return OR; }
"ori"            { return ORI; }
"sb"             { return SB; }
"sh"             { return SH; }
"sll"            { return SLL; }
"slli"           { return SLLI; }
"slt"            { return SLT; }
"slti"           { return SLTI; }
"sltiu"          { return SLTIU; }
"sltu"           { return SLTU; }
"sra"            { return SRA; }
"srai"           { return SRAI; }
"srl"            { return SRL; }
"srli"           { return SRLI; }
"sw"             { return SW; }
"xor"            { return XOR; }
"xori"           { return XORI; }
"ecall"          { return ECALL; }

"ret"            { return RET; }

[0-9]+           {
                    //TODO:  need to differentiate bw imm vs offset
                    yylval.ival = atoi(yytext);
                    return IMM;
                 }
0[xX][0-9a-fA-F]+ {
                    //TODO: does it need a different field?
                    yylval.ival = strtol(yytext+2, NULL, 16); return IMM;
                 }
0[bB][01]+       { yylval.ival = strtol(yytext+2, NULL, 2); return IMM; }
zero             { yylval.ival = 0; return REG; }
ra               { yylval.ival = 1; /*return address */ return REG; }
sp               { yylval.ival = 2; /*stack pointer  */ return REG; }
gp               { yylval.ival = 3; /*global pointer */ return REG; }
tp               { yylval.ival = 4; /*thread pointer */ return REG; }
[a][0-7]         { yylval.ival = 10 + atoi(&yytext[1]); return REG; }
[t][0-2]         { yylval.ival = 5 + atoi(&yytext[1]); return REG;}
[t][3-6]         { yylval.ival = 25 + atoi(&yytext[1]); return REG;}
[s][01]          { yylval.ival = 8 + atoi(&yytext[1]); return REG;}
[s]([2-9]|[1][01]) { yylval.ival = 16 + atoi(&yytext[1]); return REG;}
[x]([0-9]|[12][0-9]|[3][01]) { 
                   yylval.ival = atoi(yytext+1); return REG; 
                 }

\."section"      { return SECTION; }
\."text"         { return D_TEXT; }
\."data"         { return D_DATA; }
\."rodata"       { return D_RODATA; }
\."bss"          { return D_BSS; }
\."size"         { return D_SIZE; }
\.glob[a]?l      { return D_GLOBAL; }
\."ascii"        { return D_ASCII; }

\.[a-zA-Z0-9]*   { return DIRECTIVE_COMMAND; }
[_]?[a-zA-Z0-9]* { yylval.sval = strdup(yytext); return LABEL; }
\"([^\"]*)\"     { yylval.sval = strdup(yytext); return STRING; }
,                { return COMMA; }
.                { cout << "Line: "<< linenum << ": char " << charnum << ", unknown token. (" << yytext << ")" << endl; }
%%

